# Built-in libraries
# import time
import pickle, os

# External libraries for Reddit use

# Personal scripts and files
from offender import Offender  # Import Offender class
from copy import deepcopy


# def check(author, user_exists):
def check(author, c_id):
    '''
    Iterates through all the offenders and adds them to the offender list if not already in it.
    Does not add the offender if found before EOF.
    
    Returns whether or not the offender is a repeat offender (boolean; variable: user_exists)
    
    Variables:
    user_exists - boolean value of whether or not the offender exists in the list of offenders
    offenders_file - file containing a list of offender class instances
    offenders - offender list loaded from offenders_file
    new_offender - new class instance of an offender if they did not previously exist
    '''
    
    user_exists = False
    offenders_file = open('offenders', 'rb')
    comment_existed = check_comment(c_id)
    
    # Check if the file is empty
    if not os.stat("offenders").st_size == 0:
        offenders = pickle.load(offenders_file)
        print("Offenders have been loaded")
    else:
        offenders = []
        print("No preexisting offenders. New offenders list created.")

    # Search for if the author is a repeat offender
    for offender in offenders:
        if offender.name == author.name and not comment_existed:  # And comment id exists...
            offender.count += 1
            user_exists = True
            print("New offense detected")
            break
        elif comment_existed:
            user_exists = True
            print("No new offenses were detected")
            break
    
    # Create a new offender if they do not already exist in the list
    if user_exists == False:
        new_offender = Offender(author.name)
        offenders.append(new_offender)
        user_exists = True
        print(author.name + " has been added to offender list")
    
    offenders_file.close()
    offenders_file = open('offenders', 'wb')
        
    pickle.dump(offenders, offenders_file)
    print("Offenders have been pickled")
    
    offenders_file.close()
    
    try:
        return comment_existed, deepcopy(offender.count)
    except:
        return comment_existed, deepcopy(new_offender.count)


def check_comment(new_id):
    '''
    Determines whether or not a comment was previously replied to.
    
    Returns whether or not the comment already exists (boolean; variable: comment_existed).
    
    Variables:
    new_id - comment id that was passed into the function to be checked
    comment_existed - boolean value of whether or not the comment exists
    comment_id_file - file containing a list of comment id's
    comment_id_list - list of comment id's
    comment_id - comment id from comment_id_list
    
    '''
    comment_existed = False
    comment_id_file = open('comment_ids', 'rb')
    
    # Check if the file is empty
    if not os.stat('comment_ids').st_size == 0:
        comment_id_list = pickle.load(comment_id_file)
        print("Comment id's have been loaded")
    else:
        comment_id_list = []
        print("No preexisting comments. New comment id list created.")
        
    # Check if the comment id already exists
    for comment_id in comment_id_list:
        if comment_id == new_id:
            comment_existed = True
            print("Comment id has been found")
            break
    
    if comment_existed == False:
        comment_id_list.append(new_id)
        print("Comment id has not been found")
    
    comment_id_file.close()
    comment_id_file = open('comment_ids', 'wb')
    
    pickle.dump(comment_id_list, comment_id_file)
    print("Comment ids have been pickled")
    
    comment_id_file.close()
    
    return comment_existed


def reply_gen(comment, count, word):
    '''
    Generates the reply. Inputs author class and outputs a reply containing count of offenses and a warning
       
    Variables:
    reply - the reply generated by the bot
    '''

    reply = '''> %WORD%
# STOP! YOU HAVE VIOLATED THE LAW!
 
*I have detected your use of foul language.*
 
**Your offense count has increased by 1, to a total of %COUNT% offenses.**
 
^(I am a bot)'''
    
    d = {"%COUNT%" : count, "%WORD%" : word}
    
    for i, j in d.items():
        reply = reply.replace(i, j)
     
    comment.reply(reply)
       
    return reply


def srch(subreddit, KEYWORDS):
    '''
    Checks the 20 "hot" submissions in a subreddit for a keyword.
    Then, it will send the data to another function where an offender
    class will be created and user data is stored.
    
    Variables:
    submission - Reddit post submission
    comment - a comment in the submission
    author - the author of a comment
    split_comment - list of each word in the author's comment
    word - word in split_comment
    
    '''
    
    user_exists = False
    
    for submission in subreddit.hot(limit=20):
        submission.comments.replace_more(limit=None)
        submission.comments_sort = 'hot'
        
        for comment in submission.comments.list():   
            user_exists = False         
            author = comment.author
            split_comment = comment.body.lower().split(' ')
            
            for word in split_comment:
                if user_exists:
                    break                
                elif word.lower() in KEYWORDS:
                    comment_existed, count = check(author, comment.id)

                    if not comment_existed:
                        print(author.name + ' has spoken profanely ' + str(count) + ' times.')
                        reply_gen(comment, str(count), word)
                        return
                    
    return
