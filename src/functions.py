# Built-in libraries
# import time
import pickle, os

#External libraries for Reddit use

# Personal scripts and files
from offender import Offender #Import Offender class
from copy import deepcopy #Needed to avoid problems with pointers

# def check(author, user_exists):
def check(author, c_id):
    '''
    Iterates through all the offenders and adds them to the offender list if not already in it.
    Does not add the offender if found before EOF.
    
    Returns whether or not the offender is a repeat offender (boolean; variable: user_exists)
    
    Variables:
    user_exists - boolean value of whether or not the offender exists in the list of offenders
    offenders_file - file containing a list of offender class instances
    offenders - offender list loaded from offenders_file
    new_offender - new class instance of an offender if they did not previously exist
    '''
    
    user_exists = False
    offenders_file = open('offenders', 'rb')
    comment_existed = check_comment(c_id)
    
    #Check if the file is empty
    if not os.stat("offenders").st_size == 0:
        offenders = pickle.load(offenders_file)
    else:
        offenders = []

    # Search for if the author is a repeat offender
    for offender in offenders:
        if offender.name == author.name and not comment_existed: #And comment id exists...
            offender.count += 1
            user_exists = True
            break
        elif comment_existed:
            user_exists = True
            break
    
    # Create a new offender if they do not already exist in the list
    if user_exists == False:
        new_offender = Offender(author.name)
        offenders.append(new_offender)
    
    offenders_file.close()
    offenders_file = open('offenders', 'wb')
        
    pickle.dump(offenders, offenders_file)
    
    offenders_file.close()
    
    try:
        return user_exists, deepcopy(offender.count)
    except:
        return user_exists, deepcopy(new_offender.count)

def check_comment(new_id):
    '''
    Determines whether or not a comment was previously replied to.
    
    Returns whether or not the comment already exists (boolean; variable: comment_existed).
    
    Variables:
    new_id - comment id that was passed into the function to be checked
    comment_existed - boolean value of whether or not the comment exists
    comment_id_file - file containing a list of comment id's
    comment_id_list - list of comment id's
    comment_id - comment id from comment_id_list
    
    '''
    comment_existed = False
    comment_id_file = open('comment_ids', 'rb')
    
    # Check if the file is empty
    if not os.stat('comment_ids').st_size == 0:
        comment_id_list = pickle.load(comment_id_file)
    else:
        comment_id_list = []
        
    # Check if the comment id already exists
    for comment_id in comment_id_list:
        if comment_id == new_id:
            comment_existed = True
            break
    
    if comment_existed == False:
        comment_id_list.append(new_id)
    
    comment_id_file.close()
    comment_id_file = open('comment_ids', 'wb')
    
    pickle.dump(comment_id_list, comment_id_file)
    
    comment_id_file.close()
    
    return comment_existed

def reply_gen(comment, count, word):
    '''
    Generates the reply. Inputs author class and outputs a reply containing count of offenses and a warning
       
    Variables:
    reply - the reply generated by the bot
    '''
    reply ='''# STOP! YOU HAVE VIOLATED THE LAW!
 
> %WORD%
 
*I have detected your use of foul language.*
 
**Your offense count has increased by 1, to a total of %COUNT% offenses.**
 
^(I am a bot)'''.replace("%COUNT%", count)
     
    comment.reply(reply)
       
    return reply

def srch(subreddit, KEYWORDS):
    '''
    Checks the 20 "hot" submissions in a subreddit for a keyword.
    Then, it will send the data to another function where an offender
    class will be created and user data is stored.
    
    Variables:
    submission - Reddit post submission
    comment - a comment in the submission
    author - the author of a comment
    split_comment - list of each word in the author's comment
    word - word in split_comment
    
    '''
    
    user_exists = False
    
    for submission in subreddit.hot(limit=20):
        submission.comments.replace_more(limit=None)
#         submission.comments_sort = 'hot'
        submission.comments_sort = 'new'

        
        for comment in submission.comments.list():   
            user_exists = False         
            author = comment.author
            split_comment = comment.body.lower().split(' ')
            
            for word in split_comment:
                if user_exists:
                    break                
                elif word.lower() in KEYWORDS:
                    user_exists, count = check(author, comment.id)
#                     sin_word = deepcopy(word)

                    if user_exists and count <= 0:
                        pass
                    
                    if user_exists and count > 0:
                        print(author.name + ' has spoken profanely ' + str(count) + ' times.')
                        reply_gen(comment, str(count), word)
                        return
                    
                    
    return