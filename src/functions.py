# Built-in libraries
# import time
import pickle, os

#External libraries for Reddit use

# Personal scripts and files
from offender import Offender #Import Offender class
from copy import deepcopy #Needed to avoid problems with pointers

# def check(author, user_exists):
def check(author, c_id):
    '''
    Iterates through all the offenders and adds them to the offender list if not already in it.
    Does not add the offender if found before EOF.
    
    Returns whether or not the offender is a repeat offender (boolean; variable: user_exists)
    
    Variables:
    user_exists - boolean value of whether or not the offender exists in the list of offenders
    offenders_file - file containing a list of offender class instances
    offenders - offender list loaded from offenders_file
    new_offender - new class instance of an offender if they did not previously exist
    '''
    
    user_exists = False
    offenders_file = open('offenders', 'rb')
    comment_exists = check_comment(c_id)
    
#     #Check if the comment exists and immediately exit, moving onto the next comment
#     if comment_exists:
#         return False, 1
    
    #Check if the file is empty
    if not os.stat("offenders").st_size == 0:
        offenders = pickle.load(offenders_file)
    else:
        offenders = []

    # Search for if the author is a repeat offender
    for offender in offenders:
        if offender.name == str(author) and comment_exists: #And comment id exists...
            offender.count += 1
            user_exists = True
#             print(offender.name, ' has offended', offender.count, 'times.')
            break
    
    # Create a new offender if they do not already exist in the list
    if user_exists == False:
        new_offender = Offender(str(author), 0)
        offenders.append(new_offender)
    
    offenders_file.close()
    offenders_file = open('offenders', 'wb')
        
    pickle.dump(offenders, offenders_file)
    
    offenders_file.close()
        
    return user_exists, deepcopy(offender.count)

def check_comment(new_id):
    '''
    Determines whether or not a comment was previously replied to.
    
    Returns whether or not the comment already exists (boolean; variable: comment_exists).
    
    Variables:
    new_id - comment id that was passed into the function to be checked
    comment_exists - boolean value of whether or not the comment exists
    comment_id_file - file containing a list of comment id's
    comment_id_list - list of comment id's
    comment_id - comment id from comment_id_list
    
    '''
    comment_exists = False
    comment_id_file = open('comment_ids', 'rb')
    
    # Check if the file is empty
    if not os.stat('comment_ids').st_size == 0:
        comment_id_list = pickle.load(comment_id_file)
    else:
        comment_id_list = []
        
    # Check if the comment id already exists
    for comment_id in comment_id_list:
        if comment_id == new_id:
            comment_exists = True
            break
    
    if comment_exists == False:
        comment_id_list.append(new_id)
    
    comment_id_file.close()
    comment_id_file = open('comment_ids', 'wb')
    
    pickle.dump(comment_id_list, comment_id_file)
    
    comment_id_file.close()
    
    return comment_exists

# def reply_gen(comment, count, word):
#     '''
#     Generates the reply. Inputs author class and outputs a reply containing count of offenses and a warning
#       
#     Variables:
#     reply - the reply generated by the bot
#     '''
#       
#     reply ='''# STOP! YOU'VE VIOLATED THE LAW!
# 
# >
# 
# **I have detected your use of foul language.*
# 
# **Your offense count has increased by 1, to a total of   offenses.**
# 
# ^(I am a bot)'''
#     
#     comment.reply(reply)
#       
#     return reply

def srch(subreddit, KEYWORDS):
    '''
    Checks the 20 "hot" submissions in a subreddit for a keyword.
    Then, it will send the data to another function where an offender
    class will be created and user data is stored.
    
    Variables:
    submission - Reddit post submission
    comment - a comment in the submission
    author - the author of a comment
    split_comment - list of each word in the author's comment
    word - word in split_comment
    
    '''
    
    for submission in subreddit.hot(limit=20):
        submission.comments.replace_more(limit=None)
        submission.comments_sort = 'hot'
        
        for comment in submission.comments.list():            
            author = comment.author
            split_comment = comment.body.lower().split(' ')
            
            for word in split_comment:                
                if word in KEYWORDS:
#                     print(str(author))
#                     print(split_comment)
#                     print(comment.id)
                    user_exists, count = check(author, comment.id)
                    sin_word = deepcopy(word)
                    if user_exists:
                        pass
                    else:
                        print(str(author) + ' has spoken profanely ' + str(count) + ' times.')
#                         if count > 0:
#                             reply_gen(comment, count, word)
                        return
                    
    return